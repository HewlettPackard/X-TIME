###
# Copyright (2023) Hewlett Packard Enterprise Development LP
#
# Licensed under the Apache License, Version 2.0 (the "License");
# You may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
###

""" 
    NoC module for building SST components according to 'nocConfig' generated by 'utils.configNoc' function
"""   
import sst
from sst.xtime import Params
import copy
import numpy as np
import time

params = Params()

def configureSST(arg, nocConfig):
    """! 
    @brief      Configure SST.
    @details    Call the NoC class. Build and run the SST modules.

    @param[in]  arg:                Arguments(dict) from 'readArg'
    @param[in]  nocConfig:          NoC configuraiton (dict) from 'configureNoc'
    @return     None
    """
    if arg['printFlag'] == "yes":
        print("\nBuilding SST modules...")
    noc = arg['noc']
    if noc == 'tree':
        sstNoc = tree(nocConfig)
    elif noc == 'bus':
        sstNoc = tree(nocConfig)
    elif noc == 'booster':
        sstNoc = booster(nocConfig)
    else:
        raise TypeError("NoC type should be decided.")
    sstNoc.build()

class xtimeBase():
    def __init__(self, param):
        self.params = copy.deepcopy(param)
    def buildLink(self, source, sourceIndex, destination, destinationIndex, linkLatency, noCut=False):
        linkList = []
        for s in sourceIndex:
            for d in destinationIndex:
                link = sst.Link("{}{:d}_{}{:d}".format(source, s, destination, d), linkLatency)
                if noCut:
                    link.setNoCut()
                linkList.append(link)
        return linkList

class booster(xtimeBase):
    """!
    @brief      Tree NoC class
    """
    def __init__(self, param):
        """!
        @brief      Tree NoC class constructor
        @details    Instantiate 'control', 'demux', 'core', and 'accumulator'. Pass their configuration parameters to them.
        @param[in]  param:          Configuration parameters 
        """
        self.params = copy.deepcopy(param)

        self.control = control(self.params['control'])
        self.demux = demux(self.params['demux'])
        self.core = core(self.params['core'])
        self.accumulator = accumulator(self.params['accumulator'])

    def build(self):
        """!
        @brief      Build tree NoC
        @details    Define 'linkList', which is the list of links connecting each sub-class. Pass the list of input links and output links for each sub-class. 
        @param      linkList:       List of links ('Control-Demux', 'Demux-Core', 'Core-Accumulator', 'Accumulator-Control')
        """

        numPort = self.params['noc']['numPort']
        numLevel = self.params['noc']['numLevel']
        numPortControl = self.params['noc']['numPortControl']
        numTotalCore = numPortControl*pow(numPort, numLevel)
        linkList = {
            'Control-Demux'         : self.buildLink('Control', [0], 'Demux', [x for x in range(numPortControl)], self.params['core']['linkLatency']['Control-Demux']),
            'Demux-Core'            : self.buildLink('Demux', [0], 'Core', [x for x in range(numTotalCore)], self.params['core']['linkLatency']['Demux-Core']),
            'Core-Accumulator'      : self.buildLink('Core', [x for x in range(numTotalCore)], 'Accumulator', [0], self.params['core']['linkLatency']['Core-Accumulator']),
            'Accumulator-Control'   : self.buildLink('Accumulator', [x for x in range(numPortControl)], 'Control', [0], self.params['core']['linkLatency']['Accumulator-Control']),
        }
        self.control.build(linkList['Accumulator-Control'], linkList['Control-Demux'])
        self.demux.build(linkList['Control-Demux'], linkList['Demux-Core'])
        self.core.build(linkList['Demux-Core'], linkList['Core-Accumulator'])
        self.accumulator.build(linkList['Core-Accumulator'], linkList['Accumulator-Control'])

class tree(xtimeBase):
    """!
    @brief      Tree NoC class
    """
    def __init__(self, param):
        """!
        @brief      Tree NoC class constructor
        @details    Instantiate 'control', 'demux', 'core', and 'accumulator'. Pass their configuration parameters to them.
        @param[in]  param:          Configuration parameters 
        """
        self.params = copy.deepcopy(param)

        self.control = control(self.params['control'])
        self.demux = demux(self.params['demux'])
        self.core = core(self.params['core'])
        self.accumulator = accumulator(self.params['accumulator'])

    def build(self):
        """!
        @brief      Build tree NoC
        @details    Define 'linkList', which is the list of links connecting each sub-class. Pass the list of input links and output links for each sub-class. 
        @param      linkList:       List of links ('Control-Demux', 'Demux-Core', 'Core-Accumulator', 'Accumulator-Control')
        """

        numPort = self.params['noc']['numPort']
        numLevel = self.params['noc']['numLevel']
        numPortControl = self.params['noc']['numPortControl']
        numTotalCore = numPortControl*pow(numPort, numLevel)
        linkList = {
            'Control-Demux'         : self.buildLink('Control', [0], 'Demux', [x for x in range(numPortControl)], self.params['core']['linkLatency']['Control-Demux']),
            'Demux-Core'            : self.buildLink('Demux', [0], 'Core', [x for x in range(numTotalCore)], self.params['core']['linkLatency']['Demux-Core']),
            'Core-Accumulator'      : self.buildLink('Core', [x for x in range(numTotalCore)], 'Accumulator', [0], self.params['core']['linkLatency']['Core-Accumulator']),
            'Accumulator-Control'   : self.buildLink('Accumulator', [x for x in range(numPortControl)], 'Control', [0], self.params['core']['linkLatency']['Accumulator-Control']),
        }
        self.control.build(linkList['Accumulator-Control'], linkList['Control-Demux'])
        self.demux.build(linkList['Control-Demux'], linkList['Demux-Core'])
        self.core.build(linkList['Demux-Core'], linkList['Core-Accumulator'])
        self.accumulator.build(linkList['Core-Accumulator'], linkList['Accumulator-Control'])

class control(xtimeBase):
    """!
    @brief      Control class
    """
    def build(self, inputLinks, outputLinks):
        """!
        @brief      Build 'control'
        @details    Build sst control component (xtime.control). Connect input/output links to its input/output ports.
        @param[in]  inputLinks:      List of input links from 'Accumulator' ('Accumulator-Control').
        @param[in]  outputLinks:     List of output links to 'Demux' ('Control-Demux').
        """
        component = sst.Component('Control0', 'xtime.control')
        component.addParam('id', 0)
        component.addParams(self.params)
        for i, link in enumerate(inputLinks):
            component.addLink(link, "input_port{:d}".format(i))
        for i, link in enumerate(outputLinks):
            component.addLink(link, "output_port{:d}".format(i))

class demux(xtimeBase):
    """!
    @brief      Demux class
    """
    def build(self, inputLinks, outputLinks):
        """!
        @brief      Build 'demux'
        @details    Build sst demux components (xtime.demux). Define internal links between demux components and connect the demux components with the internal link.\n
                    Demux components at the first level connect their input ports to the inputLink ('Control-Demux').\n
                    Demux components at the last level connect their output ports to the outputLink ('Demux-Core').\n
                    When it is a single level, demux components take both inputLink and outputLink.
        @param[in]  inputLinks:      List of input links from 'Control' ('Control-Demux').
        @param[in]  outputLinks:     List of output links to 'Core' ('Demux-Core').
        """
        def buildComponent(self, id, i, level, inputLink, outputLink):
            component = sst.Component('Demux{:d}'.format(id), 'xtime.demux')
            component.addParams(self.params)
            component.addParam('id', id)
            component.addParam('level', level+1)
            component.addParam('mode', self.params[level+1][i]['mode'])
            component.addLink(inputLink, 'input_port')
            for j, link in enumerate(outputLink):
                component.addLink(link, 'output_port{:d}'.format(j))
            
        numPort = self.params['numPort']
        numPortControl = self.params['numPortControl']
        numLevel = self.params['numLevel']
        id = 0

        if (numLevel >1):
            # Last level (numLevel-1) - 'Demux-Core'
            linkList = []
            for i in range(numPortControl*pow(numPort, numLevel-1)):
                link = sst.Link('Demux{:d}'.format(id), self.params['linkLatency'])
                linkList.append(link)
                buildComponent(self, id, i, numLevel-1, link, outputLinks[i*numPort:(i+1)*numPort])
                id += 1

            # Intermediate level (1 ~ numLevel-2) - 'Demux-Demux' 
            for l in range(numLevel-2, 0, -1):
                linkNext = linkList
                linkList = []
                for i in range(numPortControl*pow(numPort, l)):
                    link = sst.Link('Demux{:d}'.format(id), self.params['linkLatency'])
                    linkList.append(link)
                    buildComponent(self, id, i, l, link, linkNext[i*numPort:(i+1)*numPort])
                    id += 1
            
            # First level (0) - 'Control-Demux' 
            linkNext = linkList
            for i in range(numPortControl):
                buildComponent(self, id, i, 0, inputLinks[i], linkNext[i*numPort:(i+1)*numPort])
                id += 1
        
        # When it is a single level, demux components take both inputLink and outputLink.
        else:
            for i in range(numPortControl):
                buildComponent(self, id, i, 0, inputLinks[i], outputLinks[i*numPort:(i+1)*numPort])
                id += 1
            
class accumulator(xtimeBase):
    """!
    @brief      Accumulator class
    """
    def build(self, inputLinks, outputLinks):
        """!
        @brief      Build 'accumulator'
        @details    Build sst accumulator components (xtime.accumulator). Define internal links between accumulator components and connect the accumulator components with the internal link.\n
                    Accumulator components at the first level connect their output ports to the outputLink ('Accumulator-Control').\n
                    Accumulator components at the last level connect their input ports to the inputLink ('Core-Accumulator').\n
                    When it is a single level, accumulator components take both inputLink and outputLink.
        @param[in]  inputLinks:     List of input links from 'Core' ('Core-Accumulator').
        @param[in]  outputLinks:    List of output links to 'Control' ('Accumulator-Control').
        """
        def buildComponent(self, id, mode, inputLink, outputLink):
            component = sst.Component('Accumulator{:d}'.format(id), 'xtime.accumulator')
            component.addParams(self.params)
            component.addParam('id', id)
            component.addParam('mode', mode)
            for j, link in enumerate(inputLink):
                component.addLink(link, 'input_port{:d}'.format(j))
            component.addLink(outputLink, 'output_port')
            
        numPort = self.params['numPort']
        numPortControl = self.params['numPortControl']
        numLevel = self.params['numLevel']
        id = 0

        if (numLevel >1):
            # Last level (numLevel-1) - 'Core-Accumulator'
            linkList = []
            for i in range(numPortControl*pow(numPort, numLevel-1)):
                link = sst.Link('Accumulator{:d}'.format(id), self.params['linkLatency'])
                linkList.append(link)
                buildComponent(self, id, 0, inputLinks[i*numPort:(i+1)*numPort], link)
                id += 1
                
            # Intermediate level (1 ~ numLevel-2) - 'Accumulator-Accumulator' 
            for l in range(numLevel-2, 0, -1):
                linkNext = linkList
                linkList = []
                for i in range(numPortControl*pow(numPort, l)):
                    link = sst.Link('Accumulator{:d}'.format(id), self.params['linkLatency'])
                    linkList.append(link)
                    buildComponent(self, id, 0, linkNext[i*numPort:(i+1)*numPort], link)
                    id += 1

            # First level (0) - 'Control-Demux' 
            linkNext = linkList
            for i in range(numPortControl):
                buildComponent(self, id, 0, linkNext[i*numPort:(i+1)*numPort], outputLinks[i])
                id += 1

        # When it is a single level, demux components take both inputLink and outputLink.
        else:
            for i in range(numPortControl):
                buildComponent(self, id, 0, inputLinks[i*numPort:(i+1)*numPort], outputLinks[i])
                id += 1

class core(xtimeBase):
    """!
    @brief      Core class
    """
    def build(self, inputLinks, outputLinks):
        """!
        @brief      Build 'core'
        @details    Build sst components for core (xtime.{driver, acam, mmr, memory, adder}). Define internal links between components and connect the components with the internal link.
        @param[in]  inputLinks:     List of input links from 'Demux' ('Demux-Core').
        @param[in]  outputLinks:    List of output links to 'Accumulator' ('Core-Accumulator').
        """
        def buildAcam(self, i, s, q, enLink, dlLink, outputLink):
            acamQueue = self.params['driver']['acamQueue']
            acamStack = self.params['driver']['acamStack']
            
            acam = sst.Component('Core{:d}_AcamS{:d}Q{:d}'.format(i, s, q), 'xtime.acam')
            acam.addParam('id', i*acamQueue*acamStack + q*acamStack + s)
            acam.addParam('verbose', self.params['verbose'])
            acam.addParam('outputDir', self.params['outputDir'])
            acam.addParams(self.params['acam'])
            acam.addParam('acamThLow', self.params['acamThLow'][i, s, q, :, :].flatten().tolist())
            acam.addParam('acamThHigh', self.params['acamThHigh'][i, s, q, :, :].flatten().tolist())
            acam.addParam('acamThXLow', self.params['acamXLow'][i, s, q, :, :].flatten().tolist())
            acam.addParam('acamThXHigh', self.params['acamXHigh'][i, s, q, :, :].flatten().tolist())
            acam.addLink(enLink, 'en_port')
            acam.addLink(dlLink, 'dl_port')
            acam.addLink(outputLink, 'output_port')

        numPort = self.params['numPort']
        numPortControl = self.params['numPortControl']
        numLevel = self.params['numLevel'] 
        numTotalCore = numPortControl*pow(numPort, numLevel)
        acamQueue = self.params['driver']['acamQueue']
        acamStack = self.params['driver']['acamStack']
        
        for i in range(numTotalCore):
            linkList = {
                'Driver-Acam(EN)'       : self.buildLink('Core{}_DriverE'.format(i), [0], 'AcamS', [x for x in range(acamStack)], self.params['linkLatency']['Driver-Acam(EN)'], True),
                'Driver-Acam(DL)'       : self.buildLink('Core{}_DriverD_AcamQ'.format(i), [x for x in range(acamQueue)], 'S', [x for x in range(acamStack)], self.params['linkLatency']['Driver-Acam(DL)'], True),
                'Acam-Mmr'              : self.buildLink('Core{}_Acam'.format(i), [x for x in range(acamStack)], 'Mmr', [0], self.params['linkLatency']['Acam-Mmr'], True),
                'Mmr-Memory'            : self.buildLink('Core{}_Mmr'.format(i), [0], 'Memory', [0], self.params['linkLatency']['Mmr-Memory'], True),
                'Memory-Adder'          : self.buildLink('Core{}_Memory'.format(i), [0], 'Adder', [0], self.params['linkLatency']['Memory-Adder'], True),
            }
            if (acamQueue != 1):
                linkList['Acam-Acam'] = self.buildLink('Core{}_AcamQ'.format(i), [x for x in range(acamQueue)], 'AcamS', [x for x in range(acamStack)], self.params['linkLatency']['Acam-Acam'], True)

            # Driver
            driver = sst.Component('Core{:d}_Driver0'.format(i), 'xtime.driver')
            driver.addParam('id', i)
            driver.addParam('verbose', self.params['verbose'])
            driver.addParam('outputDir', self.params['outputDir'])
            driver.addParams(self.params['driver'])
            for j, link in enumerate(linkList['Driver-Acam(EN)']):
                driver.addLink(link, 'en_port{:d}'.format(j))
            for j, link in enumerate(linkList['Driver-Acam(DL)']):
                driver.addLink(link, 'dl_port{:d}'.format(j))
            driver.addLink(inputLinks[i], 'input_port')

            # aCAM
            if (acamQueue == 1):
                for s in range(acamStack):
                    buildAcam(self, i, s, 0, linkList['Driver-Acam(EN)'][s], linkList['Driver-Acam(DL)'][s], linkList['Acam-Mmr'][s])
            elif (acamQueue == 2):
                for s in range(acamStack):
                    buildAcam(self, i, s, 0, linkList['Driver-Acam(EN)'][s], linkList['Driver-Acam(DL)'][s], linkList['Acam-Acam'][s])
                    buildAcam(self, i, s, 1, linkList['Acam-Acam'][s], linkList['Driver-Acam(DL)'][acamStack+s], linkList['Acam-Mmr'][s])
            else:
                for s in range(acamStack):
                    buildAcam(self, i, s, 0, linkList['Driver-Acam(EN)'][s], linkList['Driver-Acam(DL)'][s], linkList['Acam-Acam'][s])
                    buildAcam(self, i, s, acamQueue-1, linkList['Acam-Acam'][(acamQueue-2)*acamStack+s], linkList['Driver-Acam(DL)'][(acamQueue-1)*acamStack+s], linkList['Acam-Mmr'][s])
                    for q in range(1, acamQueue-1):
                        buildAcam(self, i, s, q, linkList['Acam-Acam'][(q-1)*acamStack+s], linkList['Driver-Acam(DL)'][q*acamStack+s], linkList['Acam-Acam'][q*acamStack+s])
            
            if self.params['task'] == 'classification' or self.params['task'] == 'regression':
                # MMR/Memory
                mmr = sst.Component('Core{:d}_Mmr0'.format(i), 'xtime.mmr')
                mmr.addParam('id', i)
                mmr.addParam('verbose', self.params['verbose'])
                mmr.addParam('outputDir', self.params['outputDir'])
                mmr.addParams(self.params['mmr'])
                for j, link in enumerate(linkList['Acam-Mmr']):
                    mmr.addLink(link, 'input_port{:d}'.format(j))
                mmr.addLink(linkList['Mmr-Memory'][0], 'output_port')

                memory = sst.Component('Core{:d}_Memory0'.format(i), 'xtime.memory')
                memory.addParam('id', i)
                memory.addParam('verbose', self.params['verbose'])
                memory.addParam('outputDir', self.params['outputDir'])
                memory.addParams(self.params['memory'])
                memory.addParam('logit', self.params['logit'][i,:].flatten().tolist())
                memory.addParam('classID', self.params['classID'][i])
                memory.addLink(linkList['Mmr-Memory'][0], 'input_port')
                memory.addLink(linkList['Memory-Adder'][0], 'output_port')

                # Adder
                adder = sst.Component('Core{:d}_Adder0'.format(i), 'xtime.adder')
                adder.addParam('id', i)
                adder.addParam('verbose', self.params['verbose'])
                adder.addParam('outputDir', self.params['outputDir'])
                adder.addParams(self.params['adder'])
                adder.addLink(linkList['Memory-Adder'][0], 'input_port')
                adder.addLink(outputLinks[i], 'output_port')
            
            elif self.params['task'] == 'SHAP':
                #MPE
                mpe = sst.Component('Core{:d}_Mpe0'.format(i), 'xtime.mpe')
                mpe.addParam('id', i)
                mpe.addParam('verbose', self.params['verbose'])
                mpe.addParam('outputDir', self.params['outputDir'])
                mpe.addParams(self.params['mpe'])
                mpe.addParam('logit', self.params['logit'][i,:].flatten().tolist())
                mpe.addParam('classID', self.params['classID'][i])
                for j, link in enumerate(linkList['Acam-Mmr']):
                    mpe.addLink(link, 'input_port{:d}'.format(j))
                mpe.addLink(outputLinks[i], 'output_port')